\chapter{Implementation}
This chapter will describe the implementation of the entire system in the demonstrator.

\section{Platform}
To demonstrate the system, the RC car UTOR 8E from BSD racing was chosen. It has a steering servo, brushless DC motor, 

PWM signal to driver for motor and servo, 50Hz. The speed is controlled by the pulselength of the PWM signal. This was tested with the handcontroller to see what PWM signals were received at the end points. Maximum and minimum high time measured was 0.02 seconds and 0.01 seconds. Depending on how high frequencies the driver can handle, the frequency could be increased without changing the high time, potentially up until 0.02 seconds would correspond to a duty cycle of 100\%, see figure.

%TODO: Latex plot

This was tested, and gave expected results for frequencies up to 200 Hz. After this 

\section{Electrical schematics}
Two 7.4V batteries in parallel. Voltage regulator to 5V for LIDAR, Raspberry Pi, encoders and WiFi module. Voltage regulator to DC input voltage for Zedboard.

\section{Hardware functions}

\subsection{Pulse Width Modulation}
To control the speed of the motor and the position of the steering servo, Pulse Width Modulation (PWM) is used. Two hardware implemented PWM functions will be needed.

\subsection{LIDAR}
To read the distance to the preceding vehicle, the LIDAR Garmin LIDAR Lite v3 was used. Specs. The PWM interface was used. A hardware function was implemented on the FPGA to read the pulse width from the PWM signal. The length of the pulse width was counted and written on an AXI bus address, ready for the OS to be read and convert into a distance in cm. The hardware code was written in VHDL and can be seen in Appendix B.

\subsection{Encoders/Decoders}
To read the speed of each wheel, the encoders TODO were used. Specs. To convert the signals from each encoder, hardware implemented decoders were written. The decoders read A and B pulses from each encoder and counted the time between each pulse to calculate the rotational speed of the wheels. This value was written on an AXI bus address for the OS to read. The hardware code was written in VHDL and can be seen in Appendix B.

\section{RTOS tasks}

\subsection{Longitudinal control}
longitudinal\_control(), due to the limitations by the PWM, the control frequency was capped at 50 Hz, meaning a period of 20 ms. 

\subsection{Lateral control}
lateral\_control(), due to the limitations by the PWM, the control frequency was capped at 50 Hz, meaning a period of 20 ms.

\subsection{Data aggregation}
data\_aggregation(), this task needs to be activated with as high frequency as possible. 1 ms is the shortest period allowed in FMP.

\subsection{Communication}
communication(), this task is bounded by the period of the larger communication loop, more than 20 ms, used 20 ms

\section{Processor scheduling}

\begin{RTGrid}{2}{20}
	\multido{\n=0+4}{5}{
		\TaskArrDead{1}{\n}{4}
		\TaskExecDelta{1}{\n}{1}}
	\multido{\n=0+6}{3}{
	\TaskArrDead{2}{\n}{6}}
	\TaskRespTime{2}{0}{4}   % draws the hatched rectangle in [0,4]
	\TaskExecution{2}{1}{4}  % draws execution (over the previous rectangle)
	\TaskRespTime{2}{6}{4}   % draws the hatched rectangle in [6,10]
	\TaskExecution{2}{6}{8}  % draws execution
	\TaskExecution{2}{9}{10} % draws execution
	\TaskRespTime{2}{12}{4}   % draws the hatched rectangle in [12,16]
	\TaskExecution{2}{13}{16} % draws execution
\end{RTGrid}

\section{System overview}


%\begin{tikzpicture}

%\draw (0,0) -- (14,0) -- (14,16) -- (0,16) -- (0,0);
%\node [below, right] at (0,15.75) {Processing System};

%\draw (1,7.25) -- (13,7.25) -- (13,15.5) -- (1,15.5) -- (1,7.25);
%\node [below, right] at (1,15.25) {CPU};

%\draw [rounded corners] (1.5,13) -- (1.5,7.5) -- (12.5,7.5) -- (12.5,15) -- (1.5,15) -- (1.5,13);
%\node [below, right] at (1.5,14.75) {SafeG Hypervisor};

%\draw [rounded corners] (2,13) -- (2,7.75) -- (6.5,7.75) -- (6.5,14.5) -- (2,14.5) -- (2,13);
%\node [below, right] at (2,14.25) {Virtual CPU};

%\draw [rounded corners] (7.5,13) -- (7.5,7.75) -- (12,7.75) -- (12,14.5) -- (7.5,14.5) -- (7.5,13);
%\node [below, right] at (7.5,14.25) {Virtual CPU};

%\draw [rounded corners] (2.25,13.5) -- (2.25,13) -- (6.25,13) -- (6.25,14) -- (2.25,14) -- (2.25,13.5);
%\node [below, right] at (2.25,13.5) {Longitudinal control};

%\draw [rounded corners] (2.25,12.5) -- (2.25,11.75) -- (6.25,11.75) -- (6.25,12.75) -- (2.25,12.75) -- (2.25,12.5);
%\node [below, right] at (2.25,12.25) {Lateral control};

%\draw [rounded corners] (2.25,11) -- (2.25,10.5) -- (6.25,10.5) -- (6.25,11.5) -- (2.25,11.5) -- (2.25,11);
%\node [below, right] at (2.25,11) {Data aggregation};

%\draw [rounded corners] (2.25,9.75) -- (2.25,9.25) -- (6.25,9.25) -- (6.25,10.25) -- (2.25,10.25) -- (2.25,9.75);
%\node [below, right] at (2.25,9.75) {Communication};

%\draw [rounded corners] (2.25,8.5) -- (2.25,8) -- (6.25,8) -- (6.25,9) -- (2.25,9) -- (2.25,8.5);
%\node [below, right] at (2.25,8.5) {SafeG system switch};

%\draw (0,6.75) -- (14,6.75);
%\node [below, right] at (0,6.5) {Programmable Logic};

%\end{tikzpicture}
